1. Automates persistence of object  to DB by providing metadata
2. HQL - HIbernate query language used to query entities

3. How does the Hibernate work in technical perspective?
 	a. configuration file(hibernate.cfg.xml or hibernate.properties)
 	b. Map metadata with the Entities using annotation 
 	c. obtain a session from session factory and invoke persistence method   
 	
 4. What are cross cutting concerns in an application?
 	a. Security
 	b. Validation
 	c. Error handling
 	d. Logging
 	e. persistence
 	
 5. Diffrance between JPA and Hibernate
 		JPA: is a Specification provided by the vendor like hibernate or EclipseLink
 			 if you see javax.persisitence import the it is a  JPA implemetation 
 			 
 		Hibernate: featues beyond JPA
 				   Couples the application to hibernate like providing @columnand so on...
 				   if you see org.hibernate.annotation import the it is a  hibernate implementation
 				   
 				   
 				
6. Field VS Property access 
		Field Access Example: using field
		 		@Id
				@GeneratedValue(strategy=GenerationType.IDENTITY)
				@Column(name="USER_ID")
				private Long userId;
				
		Property access Example it can be done in either getter or setter
				Note: Annotate the class with  @Access(value = AccessType.PROPERTY)  -> to tell hibernate to use property level
					  Unless you have business logic to add Validation or perform business logic or not to break encapsulation  
				Getter Field access:
					@Id
					@GeneratedValue(strategy=GenerationType.IDENTITY)
					@Column(name="USER_ID")
					public Long getUserId() {
						return userId;
					}
					
7. @column Annotation
		updatable :  default will be true. in some cases you do not want to update the field when it is created, 
					few fields need not to updated once created
			Example:  
				@Column(name="CREATED_DATE", updatable = false)
				private Date createdDate;

				@Column(name="CREATED_BY", updatable = false)
				private String createdBy;
				
				
		nullable : This makes the filed cannot to inserted with null values, else it will thow constraint violation exception
			Example:	
				@Column(name="BIRTH_DATE", nullable = false)
				private Date birthDate;



8. Identifires on primary keys
		a. @GeneratedValue(strategy=GenerationType.IDENTITY)
					The sequence is generated by the undelying database where the AutoIncrement on primary key is checked in mysql
					
		b. @GeneratedValue(strategy=GenerationType.SEQUENCE, generator = "user_seq")
		   @SequenceGenerator(name ="user_seq", sequenceName = "USER_ID_SEQ")
				if we are using Oralcle DB then primary keys are generated using sequence.in this case it is USER_ID_SEQ
				so it fetches the unique from the DB it self
				
		c. @GeneratedValue(strategy = GenerationType.TABLE, generator = "user_table_generator")
			@TableGenerator(name = "user_table_generator", table = "IFINANCES_KEYS", 
				pkColumnName = "PK_NAME", valueColumnName = "PK_VALUE")
				      in this case the primary key value will be generated form the user defined table. in this case it is
				      'IFINANCES_KEYS' it has 2 column PK_NAME(primary key) PK_VALUE(Unique)
				      PK_NAME stores primary column name, in this case it is 'FINANCES_USER'
				      PK_VALUE stores next number of the primary key
				      
		d. @GeneratedValue(strategy = GenerationType.AUTO)
				let the hibernate deside the strategy based on underlying database

9. what is the use of @Tansient annotation
		if you do not want to serialize and hidernate not to consider it as a colume then we use @Tansient
		
		@Transient
		private String value;
		
		
		
10. what is the use of @Temporal annotation
		if you are using date and time object from java provided date/time/calander objects then it is better to use @Temporal annotation
		 java.util.Date 
		 java.util.Calendar
		 
		In JPA, @Temporal annotation solves the one of the major issue of converting the date and 
		time values from Java object to compatible database type and retrieving back to the application.
		
		The mapping between the Java 8 Date/Time classes and the SQL types is implicit, there is not need to 
		specify the @Temporal annotation. 
		
		Example:
				@Temporal(TemporalType.TIMESTAMP)
				@Column(name = "DATETIME_COLUMN")
				private Date datetimeColumn;

				@Temporal(TemporalType.TIMESTAMP)
				@Column(name = "TIMESTAMP_COLUMN")
				private Date timestampColumn;

				@Temporal(TemporalType.DATE)
				@Column(name = "DATE_COLUMN")
				private Date dateColumn;

				@Temporal(TemporalType.TIME)
				@Column(name = "TIME_COLUMN")
				private Date timeColumn;


11. what is the use of @Formula annotation
		it is used to return the value after the select statement is executed and then formula is calculated
		@Formula("lower(datediff(curdate(),birth_date)/365)")y
		private int age;
		
		
12. Value Types - no database identity
		Basic - String,int,float,double
		Composite Type - Aggregated type , they do not have there own identity, no database column/table
		Collection type - it can hold list of strings, list of entities
		
		
13. How to map composite value types
		this type does have a life cycle because it is not an entity and also does not define its identity,
		non of the fields are annotated with Id annotaion, this is because the in DB it has does not have it own represntaion as
		a record in table, but will be a part of bank record
		 
		@Embeddable : on the class represents that the class is composite type and can be embedded in an entity
		@Embedded : so we are pointing to embeddable type
		
		Note: it is not nesscery to annotate Embedded in bank class
		
		
																					@Embeddable
Bank Class                       |      Bank Class                   |    			Address Class                                                                                                                                                                                                     
--------------                   |      --------------               |             --------------                                                                                                                                                                                             
@ID                              |     @ID                           |         public String addressLine1;                                                                                                                                                                     
private Long bankId;             |     private Long bankId;          |         public String addressLine2;                                                                                                                                                                
private String name;             |     private String name;          |         public String city;                                                                                                                                                                                
private boolean international;   |     private boolean international;|         public String state;                                                                                                                                                                            
private Date lastUpdatedDate;  ==|=>   private Date lastUpdatedDate; |         public String zipCode;                                                                                                                                                                   
private String lastUpdatedBy;    |     private String lastUpdatedBy; |                                                                                                                                                                    
private Date createdDate;        |     private Date createdDate;     |                                                                                                                                                                          
private String createdBy;        |     private String createdBy;     |                                                                                                                                                                       
								 |     								 |
								 |	   @Embedded					 |                                                                                                                                                     
public String addressLine1;      |     private Address address;      |                                                                                                                                                                     
public String addressLine2;      |                                   |                                                                                                                                                                      
public String city;              |                                   |                                                                                                                                                                              
public String state;             |                                   |                                                                                                                                                                            
public String zipCode;           |                                   |                                                            	
		


14. overriding the embedded attribute for address
		if User class has USER_ADDRESS_LINE_1 and USER_ADDRESS_LINE_2
		in Address class has ADDRESS_LINE_1 and ADDRESS_LINE_2
		then override using the annotation using the below in User class 
		
		@Embedded
		@AttributeOverrides({
		@AttributeOverride(name="addressLine1",column = @Column(name="USER_ADDRESS_LINE_1")),
		@AttributeOverride(name="addressLine2",column = @Column(name="USER_ADDRESS_LINE_2"))})
		private Address address;		
		
		
		
15. How to map collections in DB tables
		Example:  we want to  map Bank table to Bank_Contacts table 
				  but bank table does not Contact table but can take the help of Bank_Contacts table to add while inserting
				 
		Bank Table Primary key = Bank_Contacts Table Primary key  = BANK_ID
		to add the collection add it in Bank_Contacts Table's NAME
		Add  below mapping in the bank Class
		
		//using List
		@ElementCollection
		@CollectionTable(name = "BANK_CONTACT", joinColumns = @JoinColumn(name="BANK_ID"))
		@Column(name = "NAME")
		private List<String> contacts = new ArrayList<>();
		
		//Using Map
		@ElementCollection
		@CollectionTable(name = "BANK_CONTACT", joinColumns = @JoinColumn(name = "BANK_ID"))
		@MapKeyColumn(name = "POSITION_TYPE") // Key
		@Column(name = "NAME") //Value
		private Map<String,String> contacts = new HashMap<String,String>();
		
		
		
		